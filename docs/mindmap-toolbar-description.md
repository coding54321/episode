## 마인드맵 캔버스 툴바 기능 기획서 (버튼별 상세 스펙)

> 전제: 아직 개발 전 단계이며, 이 문서는 **기획 기준 진실 소스(Single Source of Truth)**입니다. 구현 시 아래 동작/정책/예외를 기준으로 개발합니다.

---

## 1. 전체 보기 (Fit to Screen)

- **목적**
  - 캔버스에 흩어져 있는 모든 노드를 한 화면에 깔끔하게 보여줘서, 사용자가 전체 구조를 빠르게 파악할 수 있게 한다.

- **기본 동작 (유저 관점)**
  - 버튼 클릭 시, 화면이 부드럽게 이동/축소·확대되며 **모든 노드가 적당한 여백을 두고 한 화면에 들어오도록** 조정된다.
  - 애니메이션은 0.2~0.4초 정도의 `ease-out` 느낌으로, 갑작스럽지 않게 이동한다.

- **로직 (개발 기준)**
  - 현재 프로젝트의 모든 노드(`x`, `y`) 좌표를 기준으로 **bounding box**를 계산한다.
  - 뷰포트(캔버스 렌더링 영역)의 크기와 bounding box를 비교하여, 상하좌우 5~10% 여백을 두고 들어오도록 zoom/pan 값을 계산한다.
  - 줌 레벨은 `MIN_ZOOM` ~ `MAX_ZOOM` 범위 내에서만 조정한다.
  - 계산된 값으로 카메라/뷰 상태를 갱신하고, 애니메이션으로 인터폴레이션한다.

- **정책**
  - **노드 없음**: 노드가 하나도 없을 경우, 기본 줌/기본 위치(예: 중앙)에 맞추고 별도 경고는 띄우지 않는다.
  - **극단 좌표 방어**: 비정상 좌표(∞, NaN 등)는 bounding box 계산에서 제외하고, 내부 로그만 남긴다.
  - **협업 환경**: Fit to Screen은 **내 로컬 뷰에만 적용**되며, 다른 사용자의 화면에는 영향을 주지 않는다.

- **예외/에러 시나리오**
  - bounding box 계산 실패 시(모든 노드가 비정상 좌표인 경우 등):
    - 기존 위치/줌을 유지하고, 콘솔/로그에만 남긴다.
    - 사용자용 에러 토스트는 기본적으로 출력하지 않는다 (사용자는 단순히 “아무 변화 없음”으로 느끼는 수준).

---

## 2. 자동 정렬 (Auto Layout)

- **목적**
  - 사용자가 수동으로 옮기다가 엉켜버린 마인드맵을, 선택된 레이아웃 규칙에 따라 **읽기 좋은 구조로 한 번에 정리**한다.

- **기본 동작 (유저 관점)**
  - 버튼 클릭 시, 노드들이 0.2~0.5초 정도의 애니메이션으로 새로운 위치로 정렬된다.
  - 정렬 후에는 전체 구조가 균형 있게 배치되어, 각 레벨/브랜치가 명확하게 구분되어 보인다.

- **로직 (개발 기준)**
  - 현재 프로젝트에 저장된 `layoutType` 및 `layoutConfig`를 조회한다.
  - 루트(센터) 노드를 기준으로, 자식 노드들을 깊이(`level`)와 순서에 따라 배치하는 레이아웃 알고리즘을 실행한다.
  - 결과로 나온 새 좌표(`x`, `y`)를 각 노드에 적용하고, 이 상태를 저장(DB 또는 스토리지 업데이트).
  - 레이아웃 계산은 **전체 노드 집합**을 대상으로 한다. (초기 버전에서는 “부분 정렬”은 고려하지 않음)

- **정책**
  - **수동 위치 vs 자동 레이아웃**
    - v1 기준: 자동 정렬 실행 시 **모든 노드가 레이아웃 규칙에 따라 재배치**된다. (수동으로 옮긴 위치도 덮어쓴다.)
    - 추후 옵션으로 “수동 고정 노드 유지” 모드 추가 가능성은 열어두되, 기본 정책은 전체 자동 정렬.
  - **히스토리(Undo) 연동**
    - 자동 정렬 실행 전 상태는 Undo 스택에 저장되어야 한다.
    - 사용자가 Undo를 누르면 자동 정렬 이전의 모든 좌표가 복원되어야 한다.

- **예외/에러 시나리오**
  - 노드 수 과다(예: 1,000개 이상)로 인해 계산 시간이 길어질 경우:
    - 버튼 클릭 시 즉시 “정렬 중…” 상태(버튼 비활성 + 스피너)로 전환.
    - 2초 이상 걸릴 수 있는 경우를 대비해, 추후 프로파일링 후 필요 시 “노드 수가 많아 시간이 걸릴 수 있습니다” 안내 문구 고려.
  - 레이아웃 타입이 설정되어 있지 않은 경우:
    - 기본값(`radial`)을 자동으로 설정한 뒤, 레이아웃을 계산한다.

---

## 3. 레이아웃 변경 (Layout Change)

- **목적**
  - 동일한 마인드맵을 **다른 구조적 관점**에서 볼 수 있도록 레이아웃 타입을 전환한다.

- **기본 동작 (유저 관점)**
  - 레이아웃 버튼 클릭 시, 작은 드롭다운이 열리고 다음과 같은 옵션을 보여준다.
    - 원형 레이아웃: "중심 노드를 기준으로 원형으로 퍼지는 구조" (XMind 스타일)
    - 트리형 레이아웃: "왼쪽에서 오른쪽으로 뻗어나가는 계층 트리"
  - 사용자가 하나를 선택하면, **즉시 자동 정렬이 실행**되어 레이아웃이 변경된다.

- **로직 (개발 기준)**
  - 선택된 레이아웃 타입을 프로젝트 설정(`layoutType`)에 저장한다.
  - `layoutType` 변경 직후, Auto Layout과 동일한 로직을 실행하여 노드 좌표를 재계산한다.
  - 완료 후, 화면을 약간 fit-to-screen에 가깝게 조정해 사용자가 변화된 구조를 한눈에 인지하게 한다.

- **정책**
  - **프로젝트 단위 설정**
    - `layoutType`은 프로젝트 공통 설정으로, 같은 프로젝트를 여는 모든 사용자가 동일한 레이아웃 구조를 보게 된다.
  - **Undo/Redo 포함**
    - 레이아웃 타입 변경 + 그에 따른 좌표 변경은 하나의 “편집 작업”으로 Undo/Redo에 포함한다.

- **예외/에러 시나리오**
  - 레이아웃 계산 중 오류 발생 시:
    - 이전 레이아웃/좌표를 그대로 유지한다.
    - 사용자에게 짧은 토스트: "레이아웃 변경에 실패했습니다. 다시 시도해주세요."
    - 내부 로그에 상세 에러 기록.
  - 현재와 동일한 레이아웃 타입을 다시 선택한 경우:
    - 좌표 재계산 없이 단순히 메뉴만 닫는다 (UX 노이즈 최소화).

---

## 4. 그리드 토글 (Grid Toggle)

- **목적**
  - 캔버스 배경에 **정렬 참고용 그리드**를 표시하여, 사용자가 노드를 규칙적으로 배치하기 쉽게 한다.

- **기본 동작 (유저 관점)**
  - 버튼을 켜면 배경에 옅은 점/선 형태의 그리드가 나타난다.
  - 다시 누르면 그리드가 사라진다.
  - 버튼은 ON 상태에서 파란 테두리/배경으로 활성 상태를 명확히 보여준다.

- **로직 (개발 기준)**
  - `showGrid`라는 로컬 상태(또는 사용자별 설정)를 토글한다.
  - `showGrid === true`일 때, 캔버스 렌더링 레이어에 CSS/SVG 패턴으로 그리드를 그린다.

- **정책**
  - **사용자별 뷰 설정**
    - 그리드 표시 여부는 “프로젝트 설정”이 아니라 “현재 사용자/브라우저 뷰 설정”으로 관리한다.
    - 같은 프로젝트라도 사용자 A는 ON, B는 OFF가 가능.

- **예외/에러 시나리오**
  - 그리드가 FPS 저하를 유발할 정도로 무거운 경우:
    - 구현 시 최대한 경량 패턴으로 처리.
    - 심각한 문제 시, 옵션으로 자동 비활성화/경고 도입 가능.

---

## 5. 실행 취소 (Undo)

- **목적**
  - 사용자가 실수로 한 편집을 **안전하게 되돌릴 수 있는 기본 안전장치**.

- **대상 작업 (예시)**
  - 노드 추가/삭제
  - 노드 라벨 변경
  - 노드 위치 이동(드래그 종료 시점 기준)
  - 레이아웃 변경, 자동 정렬 실행
  - 기타 마인드맵 구조에 영향을 주는 편집(정책에 따라 범위 정의)

- **기본 동작 (유저 관점)**
  - 되돌릴 작업이 없으면(히스토리 없음) 버튼이 비활성화된다.
  - 활성 상태에서 클릭 시, **가장 최근 편집 상태 이전**으로 전체 마인드맵이 되돌아간다.

- **로직 (개발 기준)**
  - 편집 완료 시점마다(예: 드래그 끝, 입력 확정, 다이얼로그 저장 등) 마인드맵 상태 스냅샷을 Undo 스택에 push.
  - Undo 클릭 시:
    - Undo 스택에서 가장 최근 스냅샷을 pop 하여 현재 상태로 교체.
    - 되돌리기 전 상태는 Redo 스택에 push.

- **정책**
  - 히스토리 깊이: 최소 50~100단계 이상을 목표 (메모리/성능에 따라 튜닝).
  - 협업 환경:
    - Undo/Redo는 **내 클라이언트에서 내가 한 편집 내역 기준**으로만 동작.
    - 다른 사용자가 한 편집은 내 Undo 스택에 포함하지 않는다.

- **예외/에러 시나리오**
  - 스냅샷 포맷 변경(버전업) 등으로 일부 히스토리가 복원 불가능한 경우:
    - 해당 스냅샷을 건너뛰고 다음 스냅샷을 시도.
    - 사용자에게 "더 이전 단계로는 되돌릴 수 없습니다." 정도의 안내 토스트 고려.

---

## 6. 다시 실행 (Redo)

- **목적**
  - 사용자가 실수로 Undo를 했을 때, **이전 상태를 다시 적용**할 수 있도록 한다.

- **기본 동작 (유저 관점)**
  - Undo를 한 직후에만 Redo 버튼이 활성화된다.
  - 클릭 시, 직전 Undo로 되돌리기 전 상태가 다시 복원된다.

- **로직 (개발 기준)**
  - Undo 실행 시 현재 상태를 Redo 스택에 push.
  - Redo 클릭 시 Redo 스택의 최신 상태를 현재 상태로 교체하고, 그 직전 상태를 Undo 스택에 다시 push.
  - 사용자가 Undo 이후 새로운 편집을 수행하면 Redo 스택은 모두 비운다(일반 편집기 규칙).

- **정책/예외**
  - Redo 스택이 비어 있으면 버튼 비활성화.

---

## 7. 내보내기 (Export)

- **목적**
  - 마인드맵을 **이미지 또는 PDF 파일**로 저장하여, 발표/문서 첨부/외부 공유 등에 활용할 수 있게 한다.

- **기본 동작 (유저 관점)**
  - 내보내기 버튼 클릭 시 드롭다운 메뉴가 뜨고, 다음 옵션을 제공한다.
    - 이미지로 저장
    - PDF로 저장
  - 항목 선택 시, 백그라운드에서 렌더링이 수행된 후 브라우저의 다운로드 다이얼로그가 뜬다.

- **로직 (개발 기준)**
  - 현재 마인드맵의 **전체 노드/간선/스타일** 데이터를 기반으로, 내부 렌더링 캔버스를 생성한다.
  - 선택한 타입에 따라:
    - `image`: PNG/WebP 등 래스터 이미지로 렌더링.
    - `pdf`: A4 또는 적절한 페이지 크기에 맞춰 PDF 페이지 생성.
  - 파일 생성이 완료되면, Blob URL을 만들어 `<a download>` 클릭 방식 등으로 다운로드 트리거.

- **정책**
  - **범위**: 전체 마인드맵 기준 (현재 화면에 보이는 영역만이 아니라 전체 그래프).
  - **파일명 규칙**:
    - 예: `<프로젝트명>-mindmap.png` / `<프로젝트명>-mindmap.pdf`
    - 프로젝트명이 없으면 `mindmap-YYYYMMDD` 패턴 사용.

- **예외/에러 시나리오**
  - 노드 수가 너무 많아 렌더링이 실패하거나 브라우저 메모리를 초과하는 경우:
    - 실패 시 "내보내기에 실패했습니다. 노드 수가 많을 경우 브라우저 새로고침 후 다시 시도해주세요." 등 안내 토스트.
    - 필요 시, 특정 임계치 이상에서 경고 팝업 또는 내보내기 비활성화 정책 도입 검토.
  - 모바일 환경 등에서 파일 다운로드가 원활하지 않은 경우:
    - 최소한 실패 토스트 + 콘솔 로그는 남겨 원인 파악 가능하게 한다.

---

## 8. 공유 (Share)

- **목적**
  - 프로젝트 단위 마인드맵을 **링크로 공유**하여, 로그인하지 않은 사용자도 내용을 조회할 수 있고, 로그인한 사용자는 편집/협업할 수 있는 구조를 만든다.

- **기본 동작 (유저 관점)**
  - 버튼 클릭 시 "공유 설정" 모달이 열린다.
  - 모달에서:
    - 공유 ON/OFF 스위치
    - 현재 공유 링크 (길면 중간 생략 표시 + 전체는 복사 가능)
    - 링크 복사 버튼
    - 현재 접속 중인 공동편집자 목록(아바타/이니셜 + 이름)
  - 공유를 켜면:
    - 공유 링크가 활성화되고, 누구나 링크로 접속해 **읽기 전용으로 조회**할 수 있다.
  - 공유를 끄면:
    - 기존 공유 링크로 접근 시 "공유가 해제된 마인드맵입니다" 등의 안내 화면(또는 403)에 도달한다.

- **접근/권한 정책**
  - 링크 접속 시:
    - 비로그인 사용자: **읽기 전용 모드**
      - 노드/레이아웃/설정 편집 불가
      - 툴바 일부 버튼 비활성(Undo/Redo/Auto Layout/레이아웃 변경/설정/내보내기 등 정책에 따라 제한)
      - 상단에 "읽기 전용 모드 – 편집하려면 로그인" 배너 표시
    - 로그인 사용자:
      - 프로젝트 소유자 or 권한 있는 사용자: 전체 편집 가능
      - 권한 모델이 단순할 경우, 로그인 사용자는 모두 편집 가능으로 시작 후, 추후 Role 도입 고려

- **실시간 협업 (피그마 유사)**
  - 공유 ON 상태에서 여러 사용자가 동시에 접속하면:
    - 화면 상단 우측(또는 헤더)에 현재 접속자 아바타/이니셜 버블을 보여준다.
    - 나 자신은 "나" 표시로 구분.
  - 접속자 판단 기준:
    - `active_editors` 테이블의 `last_seen`이 **마지막 5분 이내**인 사용자를 "현재 접속"으로 간주.

- **예외/에러 시나리오**
  - 공유 상태 업데이트 API 실패:
    - 모달 내 스위치를 이전 상태로 되돌리고, "공유 설정을 저장하는 데 실패했습니다. 잠시 후 다시 시도해주세요." 토스트.
  - 공유 링크로 접근했지만, 프로젝트가 삭제/권한 변경된 경우:
    - 별도 에러 화면(프로젝트를 찾을 수 없습니다 / 접근 권한이 없습니다 등)을 노출.

---

## 9. 설정 (Settings)

- **목적**
  - 마인드맵의 **스타일/동작 옵션**을 사용자와 프로젝트 수준에서 커스터마이징할 수 있도록 한다.

- **기본 동작 (유저 관점)**
  - 버튼 클릭 시 "마인드맵 설정" 모달이 열린다.
  - 예시 탭 구성:
    - 보기 설정: 색상 테마, 노드 모서리 스타일, 선 스타일(직선/곡선), 폰트 크기 등
    - 레이아웃 설정: 기본 레이아웃 타입, 레벨 간 간격, 브랜치 간 간격 등
    - 고급 설정: 애니메이션 on/off, 성능 우선 모드 등
  - "저장" 클릭 시, 설정이 적용되고 일부 항목은 즉시 화면에 반영된다.

- **로직 (개발 기준)**
  - 설정 값은 크게 두 범주로 나눈다.
    - **프로젝트 단위 설정**: 레이아웃 타입, 기본 색상 테마 등 "공유되어야 하는" 시각 구조.
    - **사용자 단위 설정**: 그리드 표시 여부, 다크모드, 줌 감도 등 개인 취향.
  - 저장 시:
    - 프로젝트 단위 설정은 프로젝트 레코드에 저장.
    - 사용자 단위 설정은 로컬 스토리지 또는 사용자 설정 테이블에 저장.

- **정책**
  - 협업 상황에서 프로젝트 단위 설정 변경 시:
    - 변경 직후, 현재 연결된 다른 사용자 화면에도 실시간 반영할지, 또는 재접속 시 반영할지 정책 결정 필요.
    - 초기 버전에서는 "재접속 시 반영" 정도로 단순화 가능.

- **예외/에러 시나리오**
  - 설정 저장 실패:
    - 모달 내에서 저장 버튼을 다시 활성화하고, "설정 저장에 실패했습니다. 다시 시도해주세요." 토스트.
    - 이전 설정값으로 롤백.
  - 입력 값 검증 실패(예: 허용 범위 밖 숫자):
    - 인풋 하단에 에러 메시지 표시, 저장 버튼 비활성화.

---

## 10. 툴바 UI 구조 요약

- **위치/레이어**
  - 캔버스 좌측 상단 고정: `absolute top-4 left-4`
  - 다른 UI보다 상위 레벨: `z-index: 50`

- **버튼 그룹 구성**
  - 상단: 전체 보기, 자동 정렬, 레이아웃 변경
  - 중간: 그리드 토글, (있다면) Undo/Redo 그룹
  - 하단: 내보내기, 공유, 설정

- **시각 스타일**
  - 공통: 흰색 카드형 버튼, 라이트/다크 모드 모두 지원
  - Hover 시 배경 색상/테두리 색상 변화
  - 활성화 상태(토글류)는 파란색 테두리/배경으로 구분

- **툴팁 정책**
  - 각 버튼은 300ms 지연 후 툴팁 노출
  - 툴팁 위치는 기본적으로 버튼의 오른쪽(`side="right"`)

